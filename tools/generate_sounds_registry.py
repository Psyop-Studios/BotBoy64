#!/usr/bin/env python3
"""
Generate sounds_generated.h from Makefile jukebox track lists.

This script parses the Makefile's JUKEBOX_MUSIC and JUKEBOX_SFX variables
to generate a header file with arrays for the jukebox sound test.

To add tracks to the jukebox, edit the JUKEBOX_MUSIC and JUKEBOX_SFX
variables in the Makefile.
"""

import os
import re

# Configuration
MAKEFILE = "Makefile"
OUTPUT_FILE = "src/sounds_generated.h"


def filename_to_display_name(filename):
    """Convert a filename to a human-readable display name."""
    # Remove extension if present
    name = os.path.splitext(filename)[0]

    # Special cases - add custom names here
    special_names = {
        # Music - Custom track names
        "scrap1": "Scrapyard Theme",
        "scrap1-menu(full)": "Cartridge In, Feelings Out",
        "scrap1-level1(full)": "Synths Before Sentience",
        "android64break": "Expansion Pak Installed",
        "androidjungle1": "OVERCLOCKED",
        "CalmJunglescrap": "Low-Poly Love",
        "androidbreak2(finished)": "Byte Me",
        "N64GameJamIdea1": "Nut & Bolted",
        "N64Chiller3": "Hardwired Heart",
        "N64JetForceTrack": "Silicon Grief",
        # SFX
        "BoltCollected": "Bolt Collected",
        "N64_Press_A_5": "Confirm",
        "N64_Press_A_5_reversed": "Confirm Reversed",
        "N64SingleKey1": "Key Press 1",
        "N64SingleKey2": "Key Press 2",
        "N64SingleKey3": "Key Press 3",
        "N64SingleKey4": "Key Press 4",
        "N64SingleKey5": "Key Press 5",
        "N64UIHover4": "UI Hover",
    }

    if name in special_names:
        return special_names[name]

    # Convert camelCase and underscores to spaces
    # Insert space before capitals
    name = re.sub(r'([a-z])([A-Z])', r'\1 \2', name)
    # Replace underscores with spaces
    name = name.replace('_', ' ')
    # Capitalize first letter of each word
    name = name.title()

    return name


def parse_makefile_list(content, var_name):
    """
    Parse a Makefile variable that may span multiple lines with backslashes.
    Returns a list of values.
    """
    # Match the variable assignment, handling line continuations
    # Pattern: VAR_NAME := value1 \
    #                     value2 \
    #                     value3
    pattern = rf'^{var_name}\s*:=\s*(.+?)(?=\n[A-Za-z_]|\n\n|\Z)'
    match = re.search(pattern, content, re.MULTILINE | re.DOTALL)

    if not match:
        return []

    # Get the full value (may span multiple lines)
    value = match.group(1)

    # Remove line continuation backslashes and join
    value = value.replace('\\\n', ' ')

    # Split on whitespace and filter empty strings
    items = [item.strip() for item in value.split() if item.strip()]

    return items


def parse_jukebox_tracks():
    """
    Parse JUKEBOX_MUSIC and JUKEBOX_SFX from the Makefile.
    Returns (music_list, sfx_list).
    """
    with open(MAKEFILE, 'r') as f:
        content = f.read()

    music = parse_makefile_list(content, 'JUKEBOX_MUSIC')
    sfx = parse_makefile_list(content, 'JUKEBOX_SFX')

    return music, sfx


def generate_header(music_files, sfx_files, output_file):
    """Generate the sounds_generated.h header file."""

    content = '''#ifndef SOUNDS_GENERATED_H
#define SOUNDS_GENERATED_H

// ============================================================
// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by tools/generate_sounds_registry.py
// ============================================================
// This file contains arrays of music and SFX tracks for the jukebox.
// To add/remove tracks, edit JUKEBOX_MUSIC and JUKEBOX_SFX in the Makefile.
// ============================================================

'''

    # Music tracks
    content += f"// Music tracks ({len(music_files)} total)\n"
    content += f"#define JUKEBOX_MUSIC_COUNT {max(len(music_files), 1)}\n\n"

    if music_files:
        content += "static const char* JUKEBOX_MUSIC[] = {\n"
        for f in music_files:
            content += f'    "rom:/{f}.wav64",\n'
        content += "};\n\n"

        content += "static const char* JUKEBOX_MUSIC_NAMES[] = {\n"
        for f in music_files:
            content += f'    "{filename_to_display_name(f)}",\n'
        content += "};\n\n"
    else:
        content += 'static const char* JUKEBOX_MUSIC[] = { NULL };\n'
        content += 'static const char* JUKEBOX_MUSIC_NAMES[] = { "No Music" };\n\n'

    # SFX tracks
    content += f"// SFX tracks ({len(sfx_files)} total)\n"
    content += f"#define JUKEBOX_SFX_COUNT {max(len(sfx_files), 1)}\n\n"

    if sfx_files:
        content += "static const char* JUKEBOX_SFX[] = {\n"
        for f in sfx_files:
            content += f'    "rom:/{f}.wav64",\n'
        content += "};\n\n"

        content += "static const char* JUKEBOX_SFX_NAMES[] = {\n"
        for f in sfx_files:
            content += f'    "{filename_to_display_name(f)}",\n'
        content += "};\n\n"
    else:
        content += 'static const char* JUKEBOX_SFX[] = { NULL };\n'
        content += 'static const char* JUKEBOX_SFX_NAMES[] = { "No SFX" };\n\n'

    content += "#endif // SOUNDS_GENERATED_H\n"

    # Write file
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    with open(output_file, 'w') as f:
        f.write(content)

    return len(music_files), len(sfx_files)


def main():
    print("Parsing Makefile for jukebox tracks...")
    music_files, sfx_files = parse_jukebox_tracks()

    print(f"\nMusic tracks ({len(music_files)}):")
    for f in music_files:
        print(f"  - {f} -> {filename_to_display_name(f)}")

    print(f"\nSFX tracks ({len(sfx_files)}):")
    for f in sfx_files:
        print(f"  - {f} -> {filename_to_display_name(f)}")

    music_count, sfx_count = generate_header(music_files, sfx_files, OUTPUT_FILE)
    print(f"\nGenerated {OUTPUT_FILE} with {music_count} music and {sfx_count} SFX tracks")


if __name__ == "__main__":
    main()
