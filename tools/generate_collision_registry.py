#!/usr/bin/env python3
"""
Auto-generates collision_registry.h that loads collision from ROM at runtime.
Uses collision_loader.h to load .col binary files from the DFS filesystem.

This version does NOT include static collision data in the ELF - all collision
is loaded at runtime from ROM, significantly reducing ELF size.
"""

import os
import re
import glob

MODELS_DIR = "src/models"
OUTPUT_FILE = "src/collision_registry.h"

def get_collision_names():
    """Find all collision files and return their names."""
    pattern = os.path.join(MODELS_DIR, "*_collision.h")
    collision_files = sorted(glob.glob(pattern))

    names = []
    chunk_groups = {}  # base_name -> [chunk_names]

    for filepath in collision_files:
        filename = os.path.basename(filepath)
        # Extract name: "Ibeam_collision.h" -> "Ibeam"
        name = filename.replace("_collision.h", "")
        names.append(name)

        # Track chunk groups
        chunk_match = re.match(r'(.+)_chunk(\d+)$', name)
        if chunk_match:
            base_name = chunk_match.group(1)
            if base_name not in chunk_groups:
                chunk_groups[base_name] = []
            chunk_groups[base_name].append(name)

    return names, chunk_groups

def main():
    names, chunk_groups = get_collision_names()

    if not names:
        print("No collision files found in", MODELS_DIR)
        return

    # Generate name array
    name_entries = ',\n    '.join(f'"{name}"' for name in names)

    # Generate chunk group data
    chunk_group_names = sorted(chunk_groups.keys())

    output = f'''#ifndef COLLISION_REGISTRY_H
#define COLLISION_REGISTRY_H

/**
 * Collision Registry - Runtime Loading Version
 *
 * All collision data is loaded from ROM (.col files) at runtime.
 * This keeps the ELF small and allows for larger collision data.
 *
 * Generated by tools/generate_collision_registry.py
 */

#include "collision.h"
#include "collision_loader.h"
#include <string.h>

// ============================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// ============================================================

// All collision mesh names (for reference/debugging)
// Suppress unused warning - kept for debug introspection
__attribute__((unused))
static const char* collision_names[] = {{
    {name_entries},
}};

#define COLLISION_NAME_COUNT {len(names)}

// Chunk group definitions (for models split into multiple chunks)
typedef struct {{
    const char* baseName;
    int chunkCount;
}} CollisionChunkGroupDef;

static const CollisionChunkGroupDef collision_chunk_group_defs[] = {{
'''

    # Add chunk group definitions
    for base_name in chunk_group_names:
        chunk_count = len(chunk_groups[base_name])
        output += f'    {{ "{base_name}", {chunk_count} }},\n'

    if not chunk_group_names:
        output += '    { NULL, 0 },  // Placeholder\n'

    output += f'''}};

#define COLLISION_CHUNK_GROUP_COUNT {len(chunk_group_names)}

// ============================================================
// COLLISION LOOKUP FUNCTIONS
// ============================================================

// Lookup collision by model name - loads from ROM if not already loaded
static inline CollisionMesh* collision_find(const char* name) {{
    return collision_load(name);
}}

// Find all collision chunks for a model (returns chunk count, fills outChunks array)
// Returns 0 if no chunks found (use collision_find instead for single mesh)
static inline int collision_find_chunks(const char* name, CollisionMesh** outChunks, int maxChunks) {{
    // Find the chunk group
    for (int i = 0; i < COLLISION_CHUNK_GROUP_COUNT; i++) {{
        if (strcmp(collision_chunk_group_defs[i].baseName, name) == 0) {{
            int count = collision_chunk_group_defs[i].chunkCount;
            if (count > maxChunks) count = maxChunks;

            // Load each chunk
            char chunkName[80];  // Enough for longest model name + "_chunk" + digits
            for (int j = 0; j < count; j++) {{
                snprintf(chunkName, sizeof(chunkName), "%s_chunk%d", name, j);
                outChunks[j] = collision_load(chunkName);
                if (!outChunks[j]) {{
                    debugf("Failed to load collision chunk: %s\\n", chunkName);
                }}
            }}
            return count;
        }}
    }}
    return 0;
}}

// Find a single collision chunk by full name (e.g., "level1_chunk0")
// Returns NULL if not found
static inline CollisionMesh* collision_find_single_chunk(const char* fullName) {{
    return collision_load(fullName);
}}

// Extract model name from path (e.g., "rom:/test_map.t3dm" -> "test_map")
static inline const char* extract_model_name(const char* path, char* buffer, int bufferSize) {{
    const char* start = path;
    const char* slash = strrchr(path, '/');
    if (slash) start = slash + 1;

    int i = 0;
    while (start[i] && start[i] != '.' && i < bufferSize - 1) {{
        buffer[i] = start[i];
        i++;
    }}
    buffer[i] = '\\0';
    return buffer;
}}

#endif // COLLISION_REGISTRY_H
'''

    with open(OUTPUT_FILE, 'w') as f:
        f.write(output)

    print(f"Generated {OUTPUT_FILE}:")
    print(f"  - {len(names)} collision meshes (loaded from ROM at runtime)")
    print(f"  - {len(chunk_group_names)} chunk groups")

if __name__ == "__main__":
    main()
